<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        // let const  块级作用域声明
        // let const共同特性：
        //      1、不存在变量提升
        //      2、不允许重复声明
        //      3、块级作用域
        //      4、暂时性死区
        // const单独特性：
        //      1、只能声明只读常量，声明的变量指向的内存地址不能改变
        // 
        // 预编译时变量不提升，但会存储在TDZ（Temporal Dead Zone）暂时性死区当中
        // js代码解析执行时如果未定义就使用TDZ中的变量会报错
        // 
        // eg：console.log(a);
        //     // var a = 0;
        //     let a = 0;
        // 预编译过程：
        //      TDZ = [a]   把TDZ看做是一个数组
        // 解释执行过程：
        //      通过控制台打印a时首先判断a是否在TDZ中，在则报错

        // 函数的扩展
        // 1、函数参数的默认值
        // eg: function getX() { return 0 }
        //     function demo(x = getX(), y = 1) {}
        //     在参数的值绝对等于undefined时才会计算默认值表达式的值
        //     参数默认值是惰性求值的
        // eg: function demo(x = y, y) {}    存在TDZ
        // 
        // 
        // 对象的扩展
        // 1 对象属性简写
        // eg: let name = '111';
        //     let obj = {
        //         name,
        //         sayName() {
        //             console.log(this.name);
        //         }
        //     }
        // 2 可计算属性
        // let first = 'first';
        // let second = 'second';
        // let third = 'third';
        // let obj = {
        //     [first + '-' + 'second']: third
        // }
        // console.log(obj[first + '-' + 'second'])
        // 3 ES6中新增的方法 
        // ECMA定义新的方法，不在全局定义，Object.prototype
        // 静态方法  Object.is() 加强的比较运算符
        // eg: Object.is(NaN, NaN);
        //     NaN === NaN; NaN == NaN;
        //     Object.is(+0, -0);
        //     +0 === -0;
        // 对象合并 obj2中的属性copy到obj1中
        // Object.assign(obj1, obj2);
        // 将对象转为数组
        // Object.keys(obj)
        // Object.values(obj)
        // Object.entries(obj)
        // 
        // 增强对象原型
        // ES6之前对同一个构造函数进行new操作会共享原型
        // obj.__proto__ 非标准的获取对象的原型对象的方法
        // Object.getPrototypeOf(obj) 标准的获取对象的原型对象的方法(ES5)
        // Object.setPrototypeOf(obj1, obj2)
        // 设置obj1的指定原型为obj2(ES6) 类似圣杯模式
        // 
        // 
        // 解构赋值 (其中使用对象属性简写方式)
        // 1 对象的解构赋值 (key: value)
        // 特点: 属性名key对应
        // 实质: 模式匹配
        // 模式是“key:”, 模式不是变量, 所以不会被赋值
        // 变量是“value”, 变量会被赋值
        // 完全解构
        // let obj = {a: 1, b: 2, c: 3}
        // let {a, b, c} = obj
        // 部分解构(不完全解构)
        // let {a, b} = obj
        // 解构失败
        // let {a, b} = {a: 1}   b = undefined
        // 
        // 解构时添加默认值
        // let {a, b=2} = {a: 1}  b的心理活动(b = b ? 2 : b)
        // 上式等于 let {a, b: b=2} = {a: 1}
        // 解构全局的Math方法
        // let {PI, radom, floor, ceil} = Math;
        // 嵌套解构
        // 
        // 2 数组的解构赋值
        // 特点: 位置对应
        // eg: swap交换a与b的值
        //     let a = 1;
        //     let b = 2;
        //     [a, b] = [b, a]
        // 详解
        // 定义时
        //      0x000   1 a
        //      0x001   2 b
        // 交换时
        //      0x002   a 2
        //      0x003   b 1
        // 
        // 
        // 数据结构  计算机中组织数据的方式
        // 数组: 有序、不定长、支持栈、队列操作
        //      FILO  arr.push, arr.pop
        //      FIFO  arr.push, arr.shift
        // 对象: 键值对结构 key: value
        // 
        // 数组去重: '1'和1使用对象的方式不能去重
        // key值存储对象会发生什么
        // 
        // ES6新的数据结构
        // Map Set
        // Map是字典、索引、目录, 是加强的对象
        // let map = new Map([[key: value], [key: value]]);
        // map.set(key, value);  类似于obj.key = value
        // map.get(key);  类似于obj.key
        // map.has(key);  是否存在该key值
        // map.delete(key);  删除某个key的数据
        // map.clear();  清空map中所有的数据
        // 
        // let Wmap = WeakMap();
        // WeakMap弱引用
        // 
        // 内存回收机制
        //     定时清理内存
        //     内存达到一定量
        // 
        // Set
        // 特点: 有序列表  包含相互独立且不相等的值
        // let set = new Set([1, 1, 2, 3, 3, '1'])
        // 
        // 
        // ES6 String & Array
        // 
        // String
        // includes 与indexOf相似  返回值为 true / false
        // startsWidth  endsWidth  前后缀比较
        // repeat
        // 
        // 模板字符串  可嵌套使用
        // 优点
        // 1更标准的字符串 更好的处理字符串拼接问题
        // 2语义化更好
        // 3防止注入 XSS
        // let str = `${name} doing ${sth}`
        // {}中的内容不是字符串都会隐式调用对象的toString()方法
        // 模板中可以写表达式  函数
        // eg: let multi = `${a}x${b}=${a*b}`
        // 
        // 标签模板  标签 => 函数
        // alert('hello')  alert`hello`
        // 按照模板分开
        // function print(arg1, arg2) {
        //     console.log(arguments)
        // }
        // print`12${3}4${5}6`
        // arguments = ['12', '4', '6'], 3, 5
        // 
        // ES6 Array
        // Array.of()  加强的Array构造函数  
        // 统一返回由参数构成的数组
        // Array.from(classArr) 将类数组转化成数组 arguments domNode
        // 通过操作数组的方法操作类数组
        // ES6之前 Array.prototype.filter.call(classArr)
        // 
        // ES6之前 Array.prototype.indexOf() 不能查找NaN
        // find(fn)  模糊查找  找到立即直接返回该值 不再往下查找
        // findIndex(fn)  精确查找  找到立即直接返回该值的索引 不再往下查找
        // 
        // 初始化填充数据
        // fill(value, start=0, end=length)


    </script>
</body>
</html>